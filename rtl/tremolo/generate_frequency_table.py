#!/bin/python3
#
# MIT License
#
# Copyright (c) 2024 Dmitriy Nekrasov
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# ---------------------------------------------------------------------------------
#
# This script generates memory initialization file with lookup table
# freq number --> probability of the cotrol sawtooth increment per audio sample
# The reason is that we want ftrequency to change linear when we turn
# potentiometeir, from f0 to f255.
#
# -- Dmitry Nekrasov <bluebag@yandex.ru>   Sun, 07 Apr 2024 22:13:40 +0300

import numpy as np

# The number of frequencies in the frequency table
NFREQ = 256

# This is the number of increment atoms inside one quadrant. Cordic
# resolution in hardware is planned to be 9-bit (for a quadrant), so
# here is the value that represents this fact. 2048 increments to pass whole
# cycle
CORDIC_FACTOR = 2048

SAMPLE_RATE = 44100

# Resolution of probability. Rather a spontaneous choice
RESOLUTION = 2**16

# How many bits is required to represent bit probability (log2(RESOLUTION) + one
# additional bit to represent 2**16 itself)
BITS=17

# Highest frequency, pot is in the leftmost position, Hz
f_high = SAMPLE_RATE / CORDIC_FACTOR
# Lowest frequency, pot is in the rightmost position, Hz
f_low = 1.0

bit_probability    = np.zeros( NFREQ, dtype=int )
bit_probability[0] = RESOLUTION

for i in range(1,NFREQ):
    # local frequency (linear interpolation, backwards)
    f = f_high - i * (f_high - f_low) / NFREQ
    # local frequency calculated as a sawtooth signal phase increment probability
    # (per sound sample)
    bit_probability[i] = int( round( RESOLUTION * f * CORDIC_FACTOR / SAMPLE_RATE ) )


fmt = lambda x : ("0"*int(np.ceil(BITS/4) - len("%x"%x)) ) + "%x"%x

f  = open( "tremolo_frequency_table.mem", "w" )
f.write(  "// This file is automatically generated by generate_frequency_table.py program\n" )
f.write(  "// Number of steps : 256\n")
f.write( f"// Highest frequency : {f_high} Hz\n")
f.write( f"// Lowest frequency  : {f_low} Hz\n\n")
f.write( f"//WIDTH={BITS};\n")
f.write( f"//DEPTH=256;\n")
f.write( f"//DATA_RADIX=HEX;\n\n")
for i in range( len( bit_probability ) ):
    f.write( f"{fmt(bit_probability[i])}\n" )
f.close()
